using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Breeze.PocoMetadata
{
    /// <summary>
    /// Builds a data structure containing the metadata required by Breeze.
    /// <see cref="http://www.breezejs.com/documentation/breeze-metadata-format"/>
    /// </summary>
    public class PocoMetadataBuilder
    {
        private Metadata _map;
        private List<Dictionary<string, object>> _typeList;
        private Dictionary<string, object> _resourceMap;
        private HashSet<string> _typeNames;
        private List<Dictionary<string, object>> _enumList;
        private List<Type> _types;
        private List<Type> _entityTypes;
        private EntityDescriptor _describer;

        public PocoMetadataBuilder(EntityDescriptor describer)
        {
            this._describer = describer;
        }

        /// <summary>
        /// Build the Breeze metadata as a nested Dictionary.  
        /// The result can be converted to JSON and sent to the Breeze client.
        /// </summary>
        /// <param name="classMeta">Entity metadata types to include in the metadata</param>
        /// <returns></returns>
        public Metadata BuildMetadata(IEnumerable<Type> types)
        {
            InitMap();
            _types = types.Where(t => _describer.Include(t)).ToList();
            _entityTypes = types.Where(t => !_describer.IsComplexType(t)).ToList();

            foreach (var t in _types)
            {
                AddType(t);
            }

            if (_enumList.Any())
            {
                _map.Add("enumTypes", _enumList);
            }
            return _map;
        }

        /// <summary>
        /// Populate the metadata header.
        /// </summary>
        void InitMap()
        {
            _map = new Metadata();
            _typeList = new List<Dictionary<string, object>>();
            _typeNames = new HashSet<string>();
            _resourceMap = new Dictionary<string, object>();
            _map.ForeignKeyMap = new Dictionary<string, string>();
            _enumList = new List<Dictionary<string, object>>();
            _map.Add("localQueryComparisonOptions", "caseInsensitiveSQL");
            _map.Add("structuralTypes", _typeList);
            _map.Add("resourceEntityTypeMap", _resourceMap);
        }

        /// <summary>
        /// Add the metadata for an entity.
        /// </summary>
        /// <param name="type">Type for which metadata is being generated</param>
        void AddType(Type type)
        {
            // "Customer:#Breeze.Models.NorthwindIBModel": {
            var classKey = type.Name + ":#" + type.Namespace;
            var cmap = new Dictionary<string, object>();
            _typeList.Add(cmap);

            cmap.Add("shortName", type.Name);
            cmap.Add("namespace", type.Namespace);

            if (_describer.IsComplexType(type))
            {
                cmap.Add("isComplexType", true);
            }
            else
            {
                // Only identify the base type if it is also an entity in the type list
                if (_entityTypes.Contains(type.BaseType))
                {
                    var baseTypeName = type.BaseType.Name + ":#" + type.BaseType.Namespace;
                    cmap.Add("baseTypeName", baseTypeName);
                }

                if (type.IsAbstract)
                {
                    cmap.Add("isAbstract", true);
                }
                // Get the autoGeneratedKeyType for this type
                var keyGenerator = _describer.GetAutoGeneratedKeyType(type);
                if (keyGenerator != null)
                {
                    cmap.Add("autoGeneratedKeyType", keyGenerator);
                }

                var resourceName = _describer.GetResourceName(type);
                cmap.Add("defaultResourceName", resourceName);
                _resourceMap.Add(resourceName, classKey);
            }


            var dataList = new List<Dictionary<string, object>>();
            cmap.Add("dataProperties", dataList);
            var navList = new List<Dictionary<string, object>>();

            AddClassProperties(type, dataList, navList);

            if (navList.Any())
            {
                cmap.Add("navigationProperties", navList);
            }

            // Change the autoGeneratedKeyType if an attribute was found on a data property
            var keyProp = FindEntry(dataList, "isPartOfKey");
            if (keyProp != null)
            {
                var custom = keyProp.Get("custom");
                if ("Identity".Equals(custom))
                {
                    cmap["autoGeneratedKeyType"] = "Identity";
                    keyProp.Remove("custom");
                }
                else if ("Computed".Equals(custom))
                {
                    cmap["autoGeneratedKeyType"] = "KeyGenerator";
                    keyProp.Remove("custom");
                }
            }

        }

        /// <summary>
        /// Add the properties for an entity type.
        /// </summary>
        /// <param name="type">Type for which metadata is being generated</param>
        /// <param name="dataList">will be populated with the data properties of the entity</param>
        /// <param name="navList">will be populated with the navigation properties of the entity</param>
        void AddClassProperties(Type type, List<Dictionary<string, object>> dataList, List<Dictionary<string, object>> navList)
        {
            // Get properties for the given class
            var propertyInfos = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);

            // Exclude properties that are declared on a base class that is also in the type list
            // those properties will be defined in the metadata for the base class
            propertyInfos = propertyInfos.Where(p => p.DeclaringType.Equals(type) || !_entityTypes.Contains(p.DeclaringType)).ToArray();

            foreach(var propertyInfo in propertyInfos)
            {
                var elementType = GetElementType(propertyInfo.PropertyType);
                if (_types.Contains(elementType) && !_describer.IsComplexType(elementType))
                {
                    // association to another entity in the metadata list; skip until later
                }
                else
                {
                    // data property
                    var isKey = _describer.IsKeyProperty(type, propertyInfo);
                    var isVersion = _describer.IsVersionProperty(type, propertyInfo);

                    var dmap = MakeDataProperty(type, propertyInfo, isKey, isVersion);
                    if (dmap == null) continue; // excluded
                    dataList.Add(dmap);

                    if (_describer.IsComplexType(elementType))
                    {
                        dmap["complexTypeName"] = elementType.Name + ":#" + elementType.Namespace;
                        dmap.Remove("dataType");
                    }
                }

                // add enum types to the global enum list
                var realType = propertyInfo.PropertyType;
                var types = propertyInfo.PropertyType.GetGenericArguments();
                if (types.Length > 0) realType = types[0];
                if (realType.IsEnum)
                {
                    if (!_enumList.Exists(x => x.ContainsValue(realType.Name)))
                    {
                        string[] enumNames = Enum.GetNames(realType);
                        var p = new Dictionary<string, object>();
                        p.Add("shortName", realType.Name);
                        p.Add("namespace", realType.Namespace);
                        p.Add("values", enumNames);
                        _enumList.Add(p);
                    }
                }
            }

            // Process again to handle the association properties
            foreach (var propertyInfo in propertyInfos)
            {
                var elementType = GetElementType(propertyInfo.PropertyType);
                if (_types.Contains(elementType) && !_describer.IsComplexType(elementType))
                {
                    // now handle association to other entities
                    // navigation property
                    var isKey = _describer.IsKeyProperty(type, propertyInfo);
                    var assProp = MakeAssociationProperty(type, propertyInfo, dataList, isKey);
                    navList.Add(assProp);
                }
            }
        }

        /// <summary>
        /// Make data property metadata for the entity property.  
        /// Attributes one the property are used to set some metadata values.
        /// </summary>
        /// <param name="propertyInfo">Property info for the property</param>
        /// <param name="containingType">Type containing the property</param>
        /// <param name="isKey">true if this property is part of the key for the entity</param>
        /// <param name="isVersion">true if this property contains the version of the entity (for a concurrency strategy)</param>
        /// <returns>Dictionary of metadata for the property</returns>
        private Dictionary<string, object> MakeDataProperty(Type containingType, PropertyInfo propertyInfo, bool isKey, bool isVersion)
        {
            var propType = _describer.GetDataPropertyType(containingType, propertyInfo);
            if (propType == null) return null; // exclude this property

            var nullableType = Nullable.GetUnderlyingType(propType);
            var isNullable = nullableType != null || !propType.IsValueType;
            propType = nullableType ?? propType;

            var dmap = new Dictionary<string, object>();
            dmap.Add("nameOnServer", propertyInfo.Name);
            dmap.Add("dataType", propType.Name);
            if (!isNullable) dmap.Add("isNullable", false);

            AddAttributesToDataProperty(propertyInfo, dmap);

            if (isKey) dmap["isPartOfKey"] = true;
            if (isVersion) dmap["concurrencyMode"] = "Fixed";
            if (propType.IsEnum)
            {
                dmap["dataType"] = "String";
                dmap["enumType"] = propType.Name;
            }

            var validators = (List<Dictionary<string, object>>)dmap.Get("validators");
            if (validators == null) validators = new List<Dictionary<string, object>>();

            if (!isNullable)
            {
                var already = FindEntry(validators, "name", "required");
                if (already == null)
                    validators.Add(new Dictionary<string, object>() {{"name", "required" }});
            }

            string validationType;
            if (ValidationTypeMap.TryGetValue(propType.Name, out validationType))
            {
                validators.Add(new Dictionary<string, object>() { {"name", validationType }});
            }
            if (validators.Any())
                dmap["validators"] = validators;

            return dmap;
        }

        /// <summary>
        /// Make association property metadata for the entity.
        /// Also populates the ForeignKeyMap which is used for related-entity fixup in NHContext.FixupRelationships
        /// </summary>
        /// <param name="propertyInfo">Property info describing the property</param>
        /// <param name="containingType">Type containing the property</param>
        /// <param name="dataProperties">Data properties already collected for the containingType.  "isPartOfKey" may be added to a property.</param>
        /// <param name="isKey">Whether the property is part of the key</param>
        /// <returns></returns>
        private Dictionary<string, object> MakeAssociationProperty(Type containingType, PropertyInfo propertyInfo, List<Dictionary<string, object>> dataProperties, bool isKey)
        {
            var nmap = new Dictionary<string, object>();
            var name = propertyInfo.Name;
            nmap.Add("nameOnServer", name);

            var propType = propertyInfo.PropertyType;
            var isCollection = IsCollectionType(propType);
            var relatedEntityType = isCollection ? GetElementType(propType) : propType;
            nmap.Add("entityTypeName", relatedEntityType.Name + ":#" + relatedEntityType.Namespace);
            nmap.Add("isScalar", !isCollection);

            AddAttributesToNavProperty(propertyInfo, nmap);

            var entityRelationship = containingType.FullName + '.' + name;

            // the associationName must be the same at both ends of the association.
            nmap.Add("associationName", GetAssociationName(containingType.Name, relatedEntityType.Name, null));

            if (!isCollection)
            {
                // For scalar navigation properties, we need to identify the foreign key

                Dictionary<string, object> dataProp = null;
                // Find the matching key in the data properties for this entity
                // First see if a data property was identified on an attribute of the navigation property
                object fkNames = nmap.Get("foreignKeyNamesOnServer");
                if (fkNames != null)
                {
                    // find the matching data prop using its fk name
                    var fkName = ((string[])fkNames)[0];
                    dataProp = FindEntry(dataProperties, "nameOnServer", fkName);
                }
                if (dataProp == null)
                {
                    // Next see if a data property was marked as a foreign key during attribute processing
                    dataProp = FindEntry(dataProperties, "__foreignKey", name);
                }
                if (dataProp == null)
                {
                    // Use the descriptor to guess the foreign key
                    var dataPropertyName = _describer.GetForeignKeyName(containingType, propertyInfo);
                    if (dataPropertyName != null)
                    {
                        dataProp = FindEntry(dataProperties, "nameOnServer", dataPropertyName);
                    }
                }

                if (dataProp != null)
                {
                    fkNames = new string[] { dataProp["nameOnServer"].ToString() };
                    nmap["foreignKeyNamesOnServer"] = fkNames;
                    dataProp.Remove("__foreignKey");

                    // if the navigation property is defined as part of the key, set the fk data property instead
                    if (isKey) dataProp["isPartOfKey"] = true;

                    // For many-to-one and one-to-one associations, save the relationship in ForeignKeyMap for re-establishing relationships during save
                    _map.ForeignKeyMap.Add(entityRelationship, string.Join(",", fkNames));
                }
                else
                {
                    if (_describer.ThrowOnForeignKeyError(containingType, propertyInfo))
                    {
                        throw new Exception("Cannot find foreign key property on type " + containingType.Name + " for navigation property " + propertyInfo.Name);
                    }
                    else
                    {
                        _map.ForeignKeyMap.Add(entityRelationship, "ERROR - NOT FOUND");
                    }
                }

            }

            return nmap;
        }

        /// <summary>
        /// Add to the data property map based on attributes on the class member.  Checks a list of known annotations.
        /// </summary>
        /// <param name="memberInfo">Property or field of the class for which metadata is being generated</param>
        /// <param name="dmap">Data property definition</param>
        private void AddAttributesToDataProperty(MemberInfo memberInfo, Dictionary<string, object> dmap)
        {
            var validators = new List<Dictionary<string, object>>();
            var attributes = memberInfo.GetCustomAttributes();
            foreach (var attr in attributes)
            {
                var name = attr.GetType().Name;
                if (name.EndsWith("Attribute"))
                {
                    // get the name without "Attribute" on the end
                    name = name.Substring(0, name.Length - "Attribute".Length);
                }

                if (name == "Key" || name == "PrimaryKey")
                {
                    dmap["isPartOfKey"] = true;
                }
                else if (name == "ConcurrencyCheck")
                {
                    dmap["concurrencyMode"] = "Fixed";
                }
                else if (name == "Required")
                {
                    dmap["isNullable"] = false;
                    var validator = new Dictionary<string, object>() { { "name", "required" } };
                    validators.Add(validator);
                }
                else if (name == "DefaultValue")
                {
                    dmap["defaultValue"] = GetAttributeValue(attr, "Value");
                }
                else if (name == "MaxLength")
                {
                    var max = GetAttributeValue(attr, "Length");
                    dmap["maxLength"] = max;
                    var validator = new Dictionary<string, object>() { { "name", "maxLength" }, { "maxLength", max } };
                    validators.Add(validator);
                }
                else if (name == "StringLength")
                {
                    dmap["maxLength"] = GetAttributeValue(attr, "MaximumLength");
                    var min = (int) GetAttributeValue(attr, "MinimumLength");
                    if (min > 0) dmap["minLength"] = min;
                }
                else if (name == "DatabaseGenerated")
                {
                    var opt = GetAttributeValue(attr, "DatabaseGeneratedOption").ToString();
                    if (opt != "None") dmap["custom"] = opt;
                }
                else if (name == "ForeignKey")
                {
                    // will be resolved & removed while processing navigation properties
                    dmap["__foreignKey"] = GetAttributeValue(attr, "Name");
                }
                else if (name == "InverseProperty")
                {
                    dmap["custom"] = new Dictionary<string, object> { { "inverseProperty", GetAttributeValue(attr, "Property") } };
                }
                else if (name.Contains("Validat"))
                {
                    // Assume some sort of validator.  Add all the properties of the attribute to the validation map
                    // TODO - this only works if the custom validator is recognized by the Breeze client.  Otherwise it throws an error.
                    //var validator = new Dictionary<string, object>() { { "name", camelCase(name) } };
                    //validators.Add(validator);
                    //foreach (var propertyInfo in attr.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.SetProperty | BindingFlags.FlattenHierarchy))
                    //{
                    //    var value = propertyInfo.GetValue(attr);
                    //    if (value != null)
                    //    {
                    //        validator[camelCase(propertyInfo.Name)] = value;
                    //    }
                    //}
                }
            }

            if (validators.Any())
            {
                dmap.Add("validators", validators);
            }

        }

        /// <summary>
        /// Add to the navigation property map based on attributes on the class member.  Checks a list of known annotations.
        /// </summary>
        /// <param name="memberInfo">Property or field of the class for which metadata is being generated</param>
        /// <param name="nmap">Navigation property definition</param>
        private void AddAttributesToNavProperty(MemberInfo memberInfo, Dictionary<string, object> nmap)
        {
            var attributes = memberInfo.GetCustomAttributes();
            foreach (var attr in attributes)
            {
                var name = attr.GetType().Name;
                if (name.EndsWith("Attribute"))
                {
                    // get the name without "Attribute" on the end
                    name = name.Substring(0, name.Length - "Attribute".Length);
                }

                if (name == "ForeignKey")
                {
                    var names = new string[] { GetAttributeValue(attr, "Name").ToString() };
                    nmap["foreignKeyNamesOnServer"] = names;
                }
                else if (name == "InverseProperty")
                {
                    nmap["custom"] = new Dictionary<string, object> { { "inverseProperty", GetAttributeValue(attr, "Property") } };
                }
            }
        }

        /// <summary>
        /// Find an dictionary in the list that has a property matching the value. 
        /// Matches are performed by converting values to string and doing case-insensitive comparison.
        /// </summary>
        /// <param name="entries">List of dictionaries to search</param>
        /// <param name="propertyName">Name of property in each dictionary that will be compared</param>
        /// <param name="value">Value to compare against.  If null, then any non-null value of property is a match.</param>
        /// <returns>First entry for which entry[propertyName] == value, ignoring case.</returns>
        Dictionary<string, object> FindEntry(List<Dictionary<string, object>> entries, string propertyName, string value = null)
        {
            return entries.Where(e => {
                var propValue = e.Get(propertyName);
                if (propValue == null) return false;
                if (value == null) return true;
                return string.Equals(value, propValue.ToString(), StringComparison.OrdinalIgnoreCase);
            }).FirstOrDefault();
        }

        /// <summary>
        /// Get the value of the given property of the attribute
        /// </summary>
        /// <param name="attr">Attribute to inspect</param>
        /// <param name="propertyName">Name of property</param>
        /// <returns></returns>
        private object GetAttributeValue(Attribute attr, string propertyName)
        {
            var propertyInfo = attr.GetType().GetProperty(propertyName);
            var value = propertyInfo.GetValue(attr);
            return value;
        }

        /// <summary>
        /// Return true if the type represents an array or enumerable type, false otherwise.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private bool IsCollectionType(Type type)
        {
            return type == typeof(Array)
                || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                || type.GetInterfaces().Any(t => t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IEnumerable<>));
        }

        /// <summary>
        /// Return the element type of a collection type (array or IEnumerable<typeparamref name="T"/>)
        /// For a plain IEnumerable, return System.Object
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private Type GetElementType(Type type)
        {
            if (!IsCollectionType(type)) return type;
            return type.HasElementType ? type.GetElementType() :
                (type.IsGenericType ? type.GetGenericArguments()[0] : typeof(object));
        }

        /// <summary>
        /// Creates an association name from two entity names.
        /// For consistency, puts the entity names in alphabetical order.
        /// </summary>
        /// <param name="name1"></param>
        /// <param name="name2"></param>
        /// <param name="fkNames">Used to ensure the association name is unique for a type</param>
        /// <returns></returns>
        static string GetAssociationName(string name1, string name2, string[] fkNames)
        {
            var cols = (fkNames != null) ? "_" + string.Join(" ", fkNames) : "";
            if (name1.CompareTo(name2) < 0)
                return FK + name1 + '_' + name2 + cols;
            else
                return FK + name2 + '_' + name1 + cols;
        }
        const string FK = "FK_";

        /// <summary>
        /// Change first letter to lowercase
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        private string camelCase(string s)
        {
            if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0]))
            {
                return s;
            }
            string str = char.ToLower(s[0]).ToString();
            if (s.Length > 1)
            {
                str = str + s.Substring(1);
            }
            return str;

        }

        // Map of data type to Breeze validation type
        static Dictionary<string, string> ValidationTypeMap = new Dictionary<string, string>() {
                    {"Boolean", "bool" },
                    {"Byte", "byte" },
                    {"DateTime", "date" },
                    {"DateTimeOffset", "date" },
                    {"Decimal", "number" },
                    {"Guid", "guid" },
                    {"Int16", "int16" },
                    {"Int32", "int32" },
                    {"Int64", "integer" },
                    {"Single", "number" },
                    {"Time", "duration" },
                    {"TimeSpan", "duration" },
                    {"TimeAsTimeSpan", "duration" }
                };

    }



    /// <summary>
    /// Metadata describing the entity model.  Converted to JSON to send to Breeze client.
    /// </summary>
    public class Metadata : Dictionary<string, object>
    {
        /// <summary>
        /// Map of relationship name -> foreign key name, e.g. "Customer" -> "CustomerID".
        /// Used for re-establishing the entity relationships from the foreign key values during save.
        /// This part is not sent to the client because it is separate from the base dictionary implementation.
        /// </summary>
        public IDictionary<string, string> ForeignKeyMap;
    }

}
